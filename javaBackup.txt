import org.apache.cordova.CordovaWebView;
import org.apache.cordova.CallbackContext;
import org.apache.cordova.CordovaPlugin;
import org.apache.cordova.CordovaInterface;
import org.apache.cordova.PluginResult;

import android.app.AlertDialog;
import android.util.Base64;
import android.util.Log;
import android.provider.Settings;
import android.widget.Toast;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;

import java.lang.InterruptedException;

import android.media.AudioManager;

import com.sinch.android.rtc.ClientRegistration;
import com.sinch.android.rtc.Sinch;
import com.sinch.android.rtc.SinchClient;
import com.sinch.android.rtc.SinchClientBuilder;
import com.sinch.android.rtc.SinchClientListener;
import com.sinch.android.rtc.SinchError;
import com.sinch.android.rtc.calling.Call;
import com.sinch.android.rtc.calling.CallClient;
import com.sinch.android.rtc.calling.CallClientListener;
import com.sinch.android.rtc.calling.CallListener;
import com.sinch.android.rtc.PushPair;

import java.net.HttpURLConnection;

import javax.net.ssl.HttpsURLConnection;


public class CoolPlugin extends CordovaPlugin {

    public static final String TAG = "VOIP PLUGIN";
    private Call call = null;
    private SinchClient sinchClient;
    private int duration = Toast.LENGTH_SHORT;
    private Map<String,String> checkHeaders;

    private boolean isIncomeCall=false;
    private CallbackContext baseCallbackContext;
    private CallbackContext dialCallbackContext;
    private CallbackContext hangContext;
    private CallbackContext pickUpContext;


    public CoolPlugin() {
    }


    public void initialize(CordovaInterface cordova, CordovaWebView webView) {
        super.initialize(cordova, webView);
        Log.v(TAG, "Init VoIP plugin");

    }

    //TODO
//            sinchClient.stopListeningOnActiveConnection();
//            sinchClient.terminate();

    public boolean execute(final String action,final JSONArray args, final CallbackContext callbackContext) throws JSONException {

        Log.v(TAG, "VoIP plugin received:" + action);

        if ("REGISTER".equals(action)) {


            this.baseCallbackContext = callbackContext;

            cordova.getThreadPool().execute(new Runnable() {

                public void run() {

                    try {

                        sinchClient = Sinch.getSinchClientBuilder()
                                .context(cordova.getActivity().getApplicationContext())
                                .userId(args.getString(0))
                                .applicationKey("2bd1c61e-b210-46db-86d7-b6441c84281b")
                                .applicationSecret("UZzt3EnAgk2A8zlbTvDGfA==")
                                .environmentHost("sandbox.sinch.com")
                                .build();

                    } catch (JSONException e) {

                        Log.v(TAG, "JSON FAILURE");
                        baseCallbackContext.error("JSON FAIL");

                    }

                    sinchClient.setSupportCalling(true);

                    //Enable waiting for calls
                    sinchClient.startListeningOnActiveConnection();

                    sinchClient.addSinchClientListener(new SinchClientListener() {

                        @Override
                        public void onClientStarted(SinchClient client) {

                            PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, "CLIENT_START");
                            pluginResult.setKeepCallback(true);
                            baseCallbackContext.sendPluginResult(pluginResult);

                        }

                        @Override
                        public void onClientStopped(SinchClient client) {

                            baseCallbackContext.success("CLIENT_STOP");

                        }

                        @Override
                        public void onClientFailed(SinchClient client, SinchError error) {

                            baseCallbackContext.error("CLIENT_FAIL");

                        }

                        @Override
                        public void onRegistrationCredentialsRequired(SinchClient client, ClientRegistration registrationCallback) {

                            baseCallbackContext.error("REG_REQ");
                        }

                        @Override
                        public void onLogMessage(int level, String area, String message) {
                            //TODO
                        }

                    });

                    //Starting client!!
                    sinchClient.start();

                    //Catching incoming calls
                    sinchClient.getCallClient().addCallClientListener(new CallClientListener() {
                        @Override
                        public void onIncomingCall(CallClient callClient, Call incomingCall) {

                            isIncomeCall = true;
                            //Pick up the call!
                            // Start playing ringing tone
                            call = incomingCall;

                            call.addCallListener(new CallListener() {

                                @Override
                                public void onCallProgressing(Call call) {

                                    PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, "ON_PROGRESS");
                                    pluginResult.setKeepCallback(true);
                                    baseCallbackContext.sendPluginResult(pluginResult);

                                }

                                @Override
                                public void onCallEstablished(Call call) {

                                    PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, "ESTABLISHED");
                                    pluginResult.setKeepCallback(true);
                                    baseCallbackContext.sendPluginResult(pluginResult);

                                }

                                @Override
                                public void onCallEnded(Call call) {
                                    isIncomeCall = false;
                                    PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, "END");
                                    pluginResult.setKeepCallback(true);
                                    baseCallbackContext.sendPluginResult(pluginResult);

                                }

                                @Override
                                public void onShouldSendPushNotification(Call call, List<PushPair> list) {

                                }
                            });
                        }
                    });


                    PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, "REG_OK");
                    pluginResult.setKeepCallback(true);
                    baseCallbackContext.sendPluginResult(pluginResult);

                }
            });

            return true;

        } else if ("CONF_CALL".equals(action)) {

            this.dialCallbackContext = callbackContext;

            cordova.getThreadPool().execute(new Runnable() {

                public void run() {

                    /*Map<String,String> callHeader= new HashMap<String, String>();

                    callHeader.put(sinchClient.getLocalUserId(),sinchClient.toString());*/

                    try {

                        call = sinchClient.getCallClient().callConference(args.getString(0));

                    } catch (JSONException e) {

                        Log.v(TAG, "JSON FAILURE");
                        dialCallbackContext.error("JSON_FAIL");

                    }

                    isIncomeCall = false;

                    call.addCallListener(new CallListener() {

                        @Override
                        public void onCallProgressing(Call call) {

                            PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, "ON_PROGRESS");
                            pluginResult.setKeepCallback(true);
                            dialCallbackContext.sendPluginResult(pluginResult);

                        }

                        @Override
                        public void onCallEstablished(Call call) {

                            PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, "ESTABLISHED");
                            pluginResult.setKeepCallback(true);
                            dialCallbackContext.sendPluginResult(pluginResult);

                        }

                        @Override
                        public void onCallEnded(Call call) {

                            PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, "END");
                            dialCallbackContext.sendPluginResult(pluginResult);

                        }

                        @Override
                        public void onShouldSendPushNotification(Call call, List<PushPair> list) {
                            //TODO
                        }
                    });


                }

            });

            return true;

        }  else if ("HANG".equals(action)) {

            this.hangContext= callbackContext;

            cordova.getThreadPool().execute(new Runnable() {
                public void run() {

                    call.hangup();

                    if (isIncomeCall) {

                        PluginResult pluginResult = new PluginResult(PluginResult.Status.OK);
                        pluginResult.setKeepCallback(true);
                        baseCallbackContext.sendPluginResult(pluginResult);


                    } else {

                        PluginResult pluginResult = new PluginResult(PluginResult.Status.OK);
                        pluginResult.setKeepCallback(true);
                        dialCallbackContext.sendPluginResult(pluginResult);

                    }


                    hangContext.success("HANG_SUCCESS");

                }

            });

            return true;

        } else if ("PICKUP".equals(action)) {

            pickUpContext = callbackContext;

            cordova.getThreadPool().execute(new Runnable() {
                public void run() {

                    call.answer();

                    Toast toast = Toast.makeText(cordova.getActivity().getApplicationContext(), "TAAAALK", duration);
                    toast.show();

                    pickUpContext.success();

                }
            });


            return true;

        } else if ("CHECK".equals(action)) {


            cordova.getThreadPool().execute(new Runnable() {
                public void run() {

                    String result;

                    try {

                        result = downloadUrl("https://callingapi.sinch.com/v1/conferences/id/blabla");
                        PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, result);
                        pluginResult.setKeepCallback(true);
                        callbackContext.sendPluginResult(pluginResult);


                    } catch (IOException e) {
                        Log.e("PLUGIN GET", e.toString());
                        PluginResult pluginResult = new PluginResult(PluginResult.Status.ERROR);
                        callbackContext.sendPluginResult(pluginResult);

                    } catch (JSONException e) {

                        Log.e("PLUGIN GET", e.toString());
                        PluginResult pluginResult = new PluginResult(PluginResult.Status.ERROR);
                        callbackContext.sendPluginResult(pluginResult);
                    }
                }
            });


            return true;

        } else if ("INFO".equals(action)) {


            cordova.getThreadPool().execute(new Runnable() {
                public void run() {


                }
            });


            return true;

        }else if("SHOW_H".equals(action)){



            AlertDialog.Builder builder = new AlertDialog.Builder(cordova.getActivity());
            builder.setMessage(checkHeaders.toString())
                    .setTitle("Headers");

            AlertDialog dialog = builder.create();
            dialog.show();



            callbackContext.success();
            return true;

        }


        return false;  // Returning false results in a "MethodNotFound" error.

    }

    private String downloadUrl(String myurl) throws IOException,JSONException {

        InputStream is = null;
        HttpsURLConnection conn;
        // Only display the first 500 characters of the retrieved
        // web page content.
        int len = 500;

        try {


            String key = "2bd1c61e-b210-46db-86d7-b6441c84281b";
            String secret = "UZzt3EnAgk2A8zlbTvDGfA==";
            String usernameAndPassword = "application\\" + key + ":" + secret;


            URL url = new URL(myurl);
            conn = (HttpsURLConnection) url.openConnection();

            conn.setReadTimeout(10000);
            conn.setConnectTimeout(15000);
            conn.setRequestMethod("GET");
            conn.setUseCaches(false);
            conn.setAllowUserInteraction(false);

            conn.setRequestProperty("Authorization", "basic " +
                    Base64.encodeToString(usernameAndPassword.getBytes(), Base64.NO_WRAP));


            //Authorization = "basic" + " " + Base64 ( usernameAndPassword )

            conn.setDoInput(true);
            // Starts the query

            BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            StringBuilder sb = new StringBuilder();

            conn.connect();
            Log.e("PLUGIN POST", "connect success");
            int response = conn.getResponseCode();
            Log.e("PLUGIN POST", "response success");


            //TODO

            Log.e("PLUGIN GET", "input stream success");
            // Convert the InputStream into a string
            // String contentAsString = readIt(is, len);


            String line;
            while ((line = br.readLine()) != null) {
                sb.append(line + "\n");
            }
            br.close();

            Log.e("PLUGIN GET", "toString try");

            conn.disconnect();
            Log.e("PLUGIN GET", "DISSCONNECTED");



            JSONObject jsonObj = new JSONObject(sb.toString());

            return jsonObj.toString();
            // return contentAsString;


            // Makes sure that the InputStream is closed after the app is
            // finished using it.


        }  finally {
            if (is != null) {
                is.close();

            }
        }
    }

    // Reads an InputStream and converts it to a String.
    public String readIt(InputStream stream, int len) throws IOException, UnsupportedEncodingException {
        Reader reader = null;
        reader = new InputStreamReader(stream, "UTF-8");
        char[] buffer = new char[len];
        reader.read(buffer);
        return new String(buffer);
    }

}

